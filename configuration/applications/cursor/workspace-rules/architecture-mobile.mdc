---
description: Clean Architecture rules for TypeScript mobile projects
globs:
alwaysApply: true
---

# 🏗️ Clean Architecture – Mobile

These rules codify how every mobile project should be structured so that code remains **predictable, portable, and a joy to iterate on**.

> "UI is just a function of state – keep state clean and the UI will follow." – Rule #0

---

## 1. Architecture Overview

### 1.1 Directory Organization

```
<repo>
  src/
  ├── domain/                             # Pure business concepts
  │   ├── entities/                       # Domain entities
  │   └── value-objects/                  # Value objects
  ├── application/                        # Use-cases & ports
  │   ├── use-cases/                      # Application use cases
  │   └── ports/
  │       ├── inbound/                    # Inbound ports
  │       └── outbound/                   # Outbound ports
  ├── infrastructure/                     # Platform & side-effects
  │   ├── internationalization/           # Internationalization
  │   ├── providers/                      # External API providers
  │   ├── persistence/                    # Storage adapters
  │   ├── repositories/                   # State management repositories
  │   └── navigation/                     # Navigation configuration
  ├── presentation/                       # UI layer
  │   ├── design-system/                  # Design tokens & theming
  │   │   ├── tokens/                     # Design tokens
  │   │   │   ├── colors.ts               # Color palette & semantic colors
  │   │   │   ├── spacing.ts              # Spacing scale
  │   │   │   ├── typography.ts           # Font families, sizes, weights
  │   │   │   └── animations.ts           # Animation durations & easings
  │   │   ├── themes/                     # Theme definitions
  │   │   │   ├── light.ts                # Light theme values
  │   │   │   ├── dark.ts                 # Dark theme values
  │   │   │   └── platform.ts             # iOS/Android adaptations
  │   │   └── providers/                  # Theme context & providers
  │   │       ├── theme-provider.tsx      # Theme context provider
  │   │       └── theme-hooks.ts          # useTheme, useColorScheme hooks
  │   ├── features/
  │   │   └── {entities}/                 # {Entity} feature module
  │   │       ├── components/             # Feature components
  │   │       ├── hooks/                  # Feature hooks
  │   │       └── __tests__/              # Component unit tests
  │   ├── shared/
  │   │   ├── components/
  │   │   │   ├── atoms/                  # Atomic components
  │   │   │   ├── molecules/              # Molecular components
  │   │   │   └── organisms/              # Organism components
  │   │   ├── hooks/                      # Shared hooks
  │   │   └── utils/                      # UI utilities
  │   ├── navigation/                     # Navigation components
  │   └── screens/                        # Application screens
  ├── di/                                 # Dependency injection
  ├── types/                              # Global types (to avoid)
  └── shared/                             # Cross-cutting utilities (to avoid)
```

### 1.2 Module-By-Feature (optional)

For large apps, wrap the above folders inside `modules/<feature>/` to isolate bounded contexts.

### 1.3 File Naming Conventions

| Type             | Filename Pattern        | Class/Export Pattern  | Example                                                      |
| ---------------- | ----------------------- | --------------------- | ------------------------------------------------------------ |
| **Entity**       | `{name}.entity.ts`      | `{Name}`              | `{entity}.entity.ts` → `{Entity}`                            |
| **Value Object** | `{name}.vo.ts`          | `{Name}`              | `{value}.vo.ts` → `{Value}`                                  |
| **Use Case**     | `verb-noun.use-case.ts` | `{VerbNoun}UseCase`   | `{verb}-{entity}.use-case.ts` → `{Verb}{Entity}UseCase`      |
| **Port**         | `{name}.port.ts`        | `{Name}Port`          | `{entity}-repository.port.ts` → `{Entity}RepositoryPort`     |
| **Provider**     | `{name}.provider.ts`    | `{Name}Provider`      | `{entity}.provider.ts` → `{Entity}Provider`                  |
| **Repository**   | `{name}.repository.ts`  | `{Name}Repository`    | `{impl}-{entity}.repository.ts` → `{Impl}{Entity}Repository` |
| **Component**    | `{name}.tsx`            | `{Name}` (PascalCase) | `{entity}-card.tsx` → `{Entity}Card`                         |
| **Hook**         | `use-{name}.ts`         | `use{Name}`           | `use-{entities}.ts` → `use{Entities}`                        |
| **Design Token** | `{name}.ts`             | `{name}Tokens`        | `colors.ts` → `colorTokens`                                  |
| **Theme**        | `{name}.ts`             | `{name}Theme`         | `light.ts` → `lightTheme`                                    |
| **Provider**     | `{name}-provider.tsx`   | `{Name}Provider`      | `theme-provider.tsx` → `ThemeProvider`                       |

---

## 2. Dependency Rules

```
 domain           →   ✖  nothing
 application      →   domain
 infrastructure   →   application + domain
 presentation     →   application (never directly infrastructure)
 di               →   all layers
 shared           →   ✖  nothing
```

---

## 3. Implementation Guidelines

1. **Functional & declarative** – Components are pure functions; prefer hooks over class components.
2. **Early returns & guard clauses** – keep render and logic flat.
3. **State strategy**
   • Local component state with `useState` when truly local.
   • Global cross-screen state via **Zustand** stores behind repositories.
4. **Zod validation** – All external data (API, storage, env) validated at boundaries.
5. **Error handling**
   • Expected errors returned as `Result`.
   • Unexpected errors caught by an ErrorBoundary (presentation) or global handler (native log).
6. **No side-effects in domain & application** – All I/O lives in providers/persistence.
7. **Platform code** – Use file suffixes `.ios`, `.android`, `.native` when diverging.
8. **File size** – ≤ 250 lines for UI, ≤ 300 elsewhere; split if larger.

---

## 4. Dependency Injection

• One `container.ts` exporting `createContainer()` that wires concrete implementations.
• Factories named `<token>Factory`.
• Never import container directly in production code – always via `useContainer()`.

---

## 5. Patterns Catalog

• **Atomic Design** – atoms/molecules/organisms for shared components.
• **Repository Pattern** – bridges store ↔︎ application use cases.
• **Provider Pattern** – wraps remote APIs / SDKs / sensors.
• **Hook Facade** – each feature exposes a single hook (`useBookmarks`) that glues UI ↔︎ use cases.
• **Navigation Container** – own folder under `infrastructure/navigation` with typed params.
• **Design System** – tokens in `presentation/design-system/tokens/`, themes in `themes/`, consumed via Context providers.
• **Theme Management** – light/dark themes with platform adaptations, accessed via `useTheme()` hook.
• **Design Tokens** – semantic color names (`primary`, `surface`), spacing scale (`xs`, `sm`, `md`), type scale.

---

## 6. Best Practices

- ✅ **DO** validate external data with Zod schemas
- ✅ **DO** respect layer import rules
- ✅ **DO** export public types from `index.ts`

- ✅ **DO** support dark mode & RTL layouts
- ✅ **DO** use semantic color names (`primary`, `surface`) not hex values
- ✅ **DO** define spacing as multiples of base unit (4px, 8px, 12px, 16px)
- ✅ **DO** use dependency injection via context

- ❌ **DON'T** commit `console.log` statements
- ❌ **DON'T** import infrastructure directly in presentation
- ❌ **DON'T** put business logic in components
- ❌ **DON'T** skip accessibility features
- ❌ **DON'T** hardcode colors/spacing in components
- ❌ **DON'T** mix platform-specific styling with tokens
- ❌ **DON'T** exceed 250 lines for UI components
