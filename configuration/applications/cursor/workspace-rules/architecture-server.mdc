---
description: Clean Architecture rules for TypeScript server projects
globs:
alwaysApply: true
---

# ğŸ—ï¸ Clean Architecture â€“ Server

These rules codify how every server project should be structured so that code remains **testable, maintainable, and boring-to-change**.

> "Business logic never **knows** nor **cares** how it is called or where data is stored." â€“ Rule #0

---

## 1. Architecture Overview

### 1.1 Directory Organization

```
<repo>
  src/
  â”œâ”€â”€ domain/                           # Pure business logic
  â”‚   â”œâ”€â”€ entities/                     # Domain entities
  â”‚   â””â”€â”€ value-objects/                # Value objects
  â”œâ”€â”€ application/                      # Orchestration & use cases
  â”‚   â”œâ”€â”€ use-cases/                    # Application use cases
  â”‚   â””â”€â”€ ports/
  â”‚       â”œâ”€â”€ inbound/                  # Inbound ports
  â”‚       â””â”€â”€ outbound/                 # Outbound ports
  â”œâ”€â”€ infrastructure/                   # Concrete adapters & frameworks
  â”‚   â”œâ”€â”€ inbound/                      # External entry points
  â”‚   â”‚   â”œâ”€â”€ server/                   # HTTP/API concerns
  â”‚   â”‚   â”‚   â”œâ”€â”€ controllers/          # HTTP controllers
  â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {feature}/        # Feature-specific controllers
  â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ handlers/     # Command/query handlers
  â”‚   â”‚   â”‚   â”‚       â””â”€â”€ presenters/   # Response formatters
  â”‚   â”‚   â”‚   â”œâ”€â”€ routes/               # Route definitions
  â”‚   â”‚   â”‚   â””â”€â”€ middleware/           # HTTP middleware
  â”‚   â”‚   â””â”€â”€ worker/                   # Background job concerns
  â”‚   â”‚       â”œâ”€â”€ schedulers/           # Job schedulers
  â”‚   â”‚       â”œâ”€â”€ jobs/                 # Background jobs
  â”‚   â”‚       â”‚   â””â”€â”€ {feature}/        # Feature-specific jobs
  â”‚   â”‚       â”‚       â”œâ”€â”€ handlers/     # Event/message handlers
  â”‚   â”‚       â”‚       â””â”€â”€ presenters/   # Message formatters
  â”‚   â”‚       â””â”€â”€ queues/               # Queue handlers
  â”‚   â””â”€â”€ outbound/
  â”‚       â”œâ”€â”€ repositories/             # Data repositories
  â”‚       â”œâ”€â”€ providers/                # External providers
  â”‚       â””â”€â”€ agents/                   # AI/LLM agents
  â”œâ”€â”€ di/                               # Dependency injection
  â””â”€â”€ shared/                           # Cross-cutting utilities
  requests/                             # HTTP request files for API testing
  â”œâ”€â”€ {path}/                           # Path-specific request collections
  â”‚   â”œâ”€â”€ get.http                      # GET requests for this path
  â”‚   â”œâ”€â”€ post.http                     # POST requests for this path
  â”‚   â””â”€â”€ put.http                      # PUT/PATCH requests for this path
  â””â”€â”€ get.http                          # Root endpoint requests
```

### 1.2 File Naming Conventions

| Type              | Filename Pattern              | Class/Export Pattern     | Example                                                      |
| ----------------- | ----------------------------- | ------------------------ | ------------------------------------------------------------ |
| **Entity**        | `{name}.entity.ts`            | `{Name}`                 | `{entity}.entity.ts` â†’ `{Entity}`                            |
| **Value Object**  | `{name}.vo.ts`                | `{Name}`                 | `{value}.vo.ts` â†’ `{Value}`                                  |
| **Use Case**      | `verb-noun.use-case.ts`       | `{VerbNoun}UseCase`      | `{verb}-{entity}.use-case.ts` â†’ `{Verb}{Entity}UseCase`      |
| **Port**          | `{name}.port.ts`              | `{Name}Port`             | `{entity}-repository.port.ts` â†’ `{Entity}RepositoryPort`     |
| **Controller**    | `verb-noun.controller.ts`     | `{VerbNoun}Controller`   | `{verb}-{entity}.controller.ts` â†’ `{Verb}{Entity}Controller` |
| **Handler**       | `verb-noun.handler.ts`        | `{VerbNoun}Handler`      | `{verb}-{entity}.handler.ts` â†’ `{Verb}{Entity}Handler`       |
| **Presenter**     | `{name}.presenter.ts`         | `{Name}Presenter`        | `{entity}.presenter.ts` â†’ `{Entity}Presenter`                |
| **Route**         | `{entity}.routes.ts`          | `{entity}Routes`         | `{entity}.routes.ts` â†’ `{entity}Routes`                      |
| **Middleware**    | `{name}.middleware.ts`        | `{name}Middleware`       | `auth.middleware.ts` â†’ `authMiddleware`                      |
| **Scheduler**     | `{name}.scheduler.ts`         | `{Name}Scheduler`        | `{entity}.scheduler.ts` â†’ `{Entity}Scheduler`                |
| **Queue Handler** | `{name}.handler.ts`           | `{Name}Handler`          | `{entity}-queue.handler.ts` â†’ `{Entity}QueueHandler`         |
| **Repository**    | `{impl}-{name}.repository.ts` | `{Impl}{Name}Repository` | `{impl}-{entity}.repository.ts` â†’ `{Impl}{Entity}Repository` |
| **Provider**      | `{name}.provider.ts`          | `{Name}Provider`         | `{service}.provider.ts` â†’ `{Service}Provider`                |
| **Agent**         | `{name}.agent.ts`             | `{Name}Agent`            | `{feature}.agent.ts` â†’ `{Feature}Agent`                      |
| **Job**           | `{name}.job.ts`               | `{Name}Job`              | `{action}-{entity}.job.ts` â†’ `{Action}{Entity}Job`           |
| **Factory**       | `{name}.factory.ts`           | `{name}Factory`          | `{entity}.factory.ts` â†’ `{entity}Factory`                    |

---

## 2. Dependency Rules

```
 domain        â†’   âœ–  nothing
 application   â†’   domain
 infrastructureâ†’   application + domain
 di            â†’   infrastructure + application + domain
 shared        â†’   âœ–  nothing
```

---

## 3. Implementation Guidelines

1. **Pure Functions first** â€“ Prefer simple functions; introduce classes only when stateful or polymorphic behaviour is mandatory.
2. **Early returns & guard clauses** â€“ flat control-flow, no deep nesting.
3. **Zod everywhere** â€“
   a. All external data (HTTP, DB, env) validated asap.
   b. Schemas live alongside the receiving port.
4. **Error strategy**
   â€¢ Expected errors = typed `Result<E, T>` return values.
   â€¢ Unexpected = thrown & captured by a framework-level error boundary.
5. **No side effects in domain** â€“ Domain cannot `console.log`, reach DB, or import `process.env`.
6. **Immutability** â€“ Entities/VOs expose mutation as `with*` copy methods.
7. **File size** â€“ â‰¤ 300 lines; split otherwise.

---

## 4. Dependency Injection

â€¢ Single `container.ts` exposing `createContainer()` factory.
â€¢ No decorators â€“ use explicit factory functions for tree-shakability.
â€¢ Factories named `<token>Factory` returning concrete impl.

---

## 5. Patterns Catalog

â€¢ **Agent Pattern** â€“ outbound port for AI / LLM calls (`AskHeadlineAgentPort`).
â€¢ **Task / Job Pattern** â€“ orchestrate long-running workflows; lives in `infrastructure/inbound/jobs`.
â€¢ **Configuration Port** â€“ validated env & feature flags; injected, never imported.
â€¢ **Event Bus Port** â€“ decouple async domain events; injected implementation (e.g. Kafka, in-memory).

---

## 6. Documentation

Minimum viable comments:

1. Complex domain rules â€“ explain **why** it exists.
2. Ports â€“ 1-liner describing the boundary.
3. Public use-case `execute` â€“ parameters, result, possible errors.
   Prefer Zod `.describe()` and `/** @description */` jsdoc tags over inline comments.

---

## 7. Best Practices

- âœ… **DO** validate all external data with Zod schemas
- âœ… **DO** respect layer dependency rules

- âœ… **DO** include operation context in logs
- âœ… **DO** use dependency injection via factories

- âŒ **DON'T** let infrastructure changes affect domain
- âŒ **DON'T** import across layer boundaries
- âŒ **DON'T** put side effects in domain layer
- âŒ **DON'T** skip error handling strategy
- âŒ **DON'T** exceed 300 lines per file
