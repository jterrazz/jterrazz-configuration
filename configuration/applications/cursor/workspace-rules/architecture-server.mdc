---
description: Clean Architecture rules for TypeScript server projects
globs:
alwaysApply: true
---

# 🏗️ Clean Architecture – Server

These rules codify how every server project should be structured so that code remains **testable, maintainable, and boring-to-change**.

> "Business logic never **knows** nor **cares** how it is called or where data is stored." – Rule #0

---

## 1. Architecture Overview

### 1.1 Directory Organization

```
<repo>
  src/
  ├── domain/                           # Pure business logic
  │   ├── entities/                     # Domain entities
  │   └── value-objects/                # Value objects
  ├── application/                      # Orchestration & use cases
  │   ├── use-cases/                    # Application use cases
  │   └── ports/
  │       ├── inbound/                  # Inbound ports
  │       └── outbound/                 # Outbound ports
  ├── infrastructure/                   # Concrete adapters & frameworks
  │   ├── inbound/                      # External entry points
  │   │   ├── server/                   # HTTP/API concerns
  │   │   │   ├── controllers/          # HTTP controllers
  │   │   │   │   └── {feature}/        # Feature-specific controllers
  │   │   │   │       ├── handlers/     # Command/query handlers
  │   │   │   │       └── presenters/   # Response formatters
  │   │   │   ├── routes/               # Route definitions
  │   │   │   └── middleware/           # HTTP middleware
  │   │   └── worker/                   # Background job concerns
  │   │       ├── schedulers/           # Job schedulers
  │   │       ├── jobs/                 # Background jobs
  │   │       │   └── {feature}/        # Feature-specific jobs
  │   │       │       ├── handlers/     # Event/message handlers
  │   │       │       └── presenters/   # Message formatters
  │   │       └── queues/               # Queue handlers
  │   └── outbound/
  │       ├── repositories/             # Data repositories
  │       ├── providers/                # External providers
  │       └── agents/                   # AI/LLM agents
  ├── di/                               # Dependency injection
  └── shared/                           # Cross-cutting utilities
  requests/                             # HTTP request files for API testing
  ├── {path}/                           # Path-specific request collections
  │   ├── get.http                      # GET requests for this path
  │   ├── post.http                     # POST requests for this path
  │   └── put.http                      # PUT/PATCH requests for this path
  └── get.http                          # Root endpoint requests
```

### 1.2 File Naming Conventions

| Type              | Filename Pattern              | Class/Export Pattern     | Example                                                      |
| ----------------- | ----------------------------- | ------------------------ | ------------------------------------------------------------ |
| **Entity**        | `{name}.entity.ts`            | `{Name}`                 | `{entity}.entity.ts` → `{Entity}`                            |
| **Value Object**  | `{name}.vo.ts`                | `{Name}`                 | `{value}.vo.ts` → `{Value}`                                  |
| **Use Case**      | `verb-noun.use-case.ts`       | `{VerbNoun}UseCase`      | `{verb}-{entity}.use-case.ts` → `{Verb}{Entity}UseCase`      |
| **Port**          | `{name}.port.ts`              | `{Name}Port`             | `{entity}-repository.port.ts` → `{Entity}RepositoryPort`     |
| **Controller**    | `verb-noun.controller.ts`     | `{VerbNoun}Controller`   | `{verb}-{entity}.controller.ts` → `{Verb}{Entity}Controller` |
| **Handler**       | `verb-noun.handler.ts`        | `{VerbNoun}Handler`      | `{verb}-{entity}.handler.ts` → `{Verb}{Entity}Handler`       |
| **Presenter**     | `{name}.presenter.ts`         | `{Name}Presenter`        | `{entity}.presenter.ts` → `{Entity}Presenter`                |
| **Route**         | `{entity}.routes.ts`          | `{entity}Routes`         | `{entity}.routes.ts` → `{entity}Routes`                      |
| **Middleware**    | `{name}.middleware.ts`        | `{name}Middleware`       | `auth.middleware.ts` → `authMiddleware`                      |
| **Scheduler**     | `{name}.scheduler.ts`         | `{Name}Scheduler`        | `{entity}.scheduler.ts` → `{Entity}Scheduler`                |
| **Queue Handler** | `{name}.handler.ts`           | `{Name}Handler`          | `{entity}-queue.handler.ts` → `{Entity}QueueHandler`         |
| **Repository**    | `{impl}-{name}.repository.ts` | `{Impl}{Name}Repository` | `{impl}-{entity}.repository.ts` → `{Impl}{Entity}Repository` |
| **Provider**      | `{name}.provider.ts`          | `{Name}Provider`         | `{service}.provider.ts` → `{Service}Provider`                |
| **Agent**         | `{name}.agent.ts`             | `{Name}Agent`            | `{feature}.agent.ts` → `{Feature}Agent`                      |
| **Job**           | `{name}.job.ts`               | `{Name}Job`              | `{action}-{entity}.job.ts` → `{Action}{Entity}Job`           |
| **Factory**       | `{name}.factory.ts`           | `{name}Factory`          | `{entity}.factory.ts` → `{entity}Factory`                    |

---

## 2. Dependency Rules

```
 domain        →   ✖  nothing
 application   →   domain
 infrastructure→   application + domain
 di            →   infrastructure + application + domain
 shared        →   ✖  nothing
```

---

## 3. Implementation Guidelines

1. **Pure Functions first** – Prefer simple functions; introduce classes only when stateful or polymorphic behaviour is mandatory.
2. **Early returns & guard clauses** – flat control-flow, no deep nesting.
3. **Zod everywhere** –
   a. All external data (HTTP, DB, env) validated asap.
   b. Schemas live alongside the receiving port.
4. **Error strategy**
   • Expected errors = typed `Result<E, T>` return values.
   • Unexpected = thrown & captured by a framework-level error boundary.
5. **No side effects in domain** – Domain cannot `console.log`, reach DB, or import `process.env`.
6. **Immutability** – Entities/VOs expose mutation as `with*` copy methods.
7. **File size** – ≤ 300 lines; split otherwise.

---

## 4. Dependency Injection

• Single `container.ts` exposing `createContainer()` factory.
• No decorators – use explicit factory functions for tree-shakability.
• Factories named `<token>Factory` returning concrete impl.

---

## 5. Patterns Catalog

• **Agent Pattern** – outbound port for AI / LLM calls (`AskHeadlineAgentPort`).
• **Task / Job Pattern** – orchestrate long-running workflows; lives in `infrastructure/inbound/jobs`.
• **Configuration Port** – validated env & feature flags; injected, never imported.
• **Event Bus Port** – decouple async domain events; injected implementation (e.g. Kafka, in-memory).

---

## 6. Documentation

Minimum viable comments:

1. Complex domain rules – explain **why** it exists.
2. Ports – 1-liner describing the boundary.
3. Public use-case `execute` – parameters, result, possible errors.
   Prefer Zod `.describe()` and `/** @description */` jsdoc tags over inline comments.

---

## 7. Best Practices

- ✅ **DO** validate all external data with Zod schemas
- ✅ **DO** respect layer dependency rules

- ✅ **DO** include operation context in logs
- ✅ **DO** use dependency injection via factories

- ❌ **DON'T** let infrastructure changes affect domain
- ❌ **DON'T** import across layer boundaries
- ❌ **DON'T** put side effects in domain layer
- ❌ **DON'T** skip error handling strategy
- ❌ **DON'T** exceed 300 lines per file
