---
description: Clean Architecture rules for TypeScript package projects
alwaysApply: true
---

# 🏗️ Clean Architecture – Package

These rules codify how every package project should be structured so that code remains **reusable, discoverable, and effortless to integrate**.

> "Ports define contracts, adapters implement behaviour – keep the boundaries clear." – Rule #0

---

## 1. Architecture Overview

This package follows **Clean Architecture** with **Hexagonal Architecture** principles:

- **Ports** (`src/ports/`): Interface definitions that define contracts
- **Adapters** (`src/adapters/`): Concrete implementations of ports
- **Domain-driven structure**: Organized by business domains (feature-based modules)

---

## 2. Directory Structure

### 2.1 Directory Organization

```
<repo>
  src/
  ├── ports/           # Interface definitions
  ├── adapters/        # Implementations
  │   ├── {domain-a}/  # Feature domain implementations
  │   ├── {domain-b}/  # Feature domain implementations
  │   └── utils/       # Utility classes
  └── index.ts         # Main export file
```

### 2.2 File Naming Conventions

| Type                 | Filename Pattern             | Class Name Pattern             | Example                                             |
| -------------------- | ---------------------------- | ------------------------------ | --------------------------------------------------- |
| **Port**             | `{domain}.port.ts`           | `{Domain}Port`                 | `{entity}.port.ts` → `{Entity}Port`                 |
| **Adapter**          | `{name}.adapter.ts`          | `{Name}` (no "Adapter" suffix) | `{entity}-{action}.adapter.ts` → `{Entity}{Action}` |
| **Utility**          | `{name}.ts`                  | `{Name}`                       | `{utility}.ts` → `{Utility}`                        |
| **Test**             | `{name}.test.ts`             | N/A                            | `{entity}-{action}.test.ts`                         |
| **Integration Test** | `{name}.integration.test.ts` | N/A                            | `{entity}-{action}.integration.test.ts`             |

---

## 3. Code Patterns

### 3.1 Port Definitions

```typescript
// ports/{entity}.port.ts
export interface {Entity}Port {
  /**
   * Clear JSDoc description
   */
  readonly name: string;

  /**
   * Main method with clear signature
   */
  execute(input: string): Promise<string>;
}
```

### 3.2 Adapter Implementations

```typescript
// adapters/{domain-a}/{entity}.adapter.ts
import type { {Entity}Port } from "../../ports/{entity}.port.js";

export interface {Entity}Options {
  // Configuration options
}

/**
 * Implementation of {Entity}Port with specific behavior
 */
export class {Entity} implements {Entity}Port {
  constructor(
    public readonly name: string,
    private readonly options: {Entity}Options
  ) {}

  async execute(input: string): Promise<string> {
    // Implementation
  }
}
```

### 3.3 Hexagonal Architecture Requirements

- Always implement the corresponding port interface
- Adapters must be swappable without affecting ports
- Keep port definitions pure (no implementation details)
- One adapter per concrete implementation
- Use dependency injection for loose coupling

---

## 4. Implementation Guidelines

### 4.1 Adding New Features

1. **Define the port** (interface) first
2. **Implement the adapter** with clear naming
3. **Add comprehensive tests** (unit + integration)
4. **Update main index** with proper section placement

### 4.2 Quality Gates

- All code must pass TypeScript strict checks
- Tests must pass before committing
- Lint rules must be satisfied
- Follow established naming conventions

---

## 5. Best Practices

- ✅ **DO** follow the exact naming conventions for ports vs adapters
- ✅ **DO** maintain the structured index.ts format
- ✅ **DO** implement port interfaces in adapter classes

- ❌ **DON'T** include "Adapter" in class names (only in filenames)
- ❌ **DON'T** create new files without following the established patterns
- ❌ **DON'T** break the clean architecture boundaries
