---
description: Clean Architecture rules for TypeScript packages using ports/adapters pattern with domain-driven structure
globs:
alwaysApply: true
---

# üèóÔ∏è Clean Architecture Rules

These rules codify how every TypeScript package should be structured so that code remains **reusable, discoverable, and effortless to integrate**.

> "Ports define contracts, adapters implement behaviour ‚Äì keep the boundaries clear." ‚Äì Rule #0

---

## 1. Architecture Overview

This package follows **Clean Architecture** with **Hexagonal Architecture** principles:

- **Ports** (`src/ports/`): Interface definitions that define contracts
- **Adapters** (`src/adapters/`): Concrete implementations of ports
- **Domain-driven structure**: Organized by business domains (feature-based modules)

---

## 2. File & Directory Structure

### 2.1 Directory Organization

```
src/
‚îú‚îÄ‚îÄ ports/           # Interface definitions
‚îú‚îÄ‚îÄ adapters/        # Implementations
‚îÇ   ‚îú‚îÄ‚îÄ domain-a/    # Feature domain implementations
‚îÇ   ‚îú‚îÄ‚îÄ domain-b/    # Feature domain implementations
‚îÇ   ‚îî‚îÄ‚îÄ utils/       # Utility classes
‚îî‚îÄ‚îÄ index.ts         # Main export file
```

### 2.2 File Naming Conventions

| Type                 | Filename Pattern             | Class Name Pattern             | Example                                       |
| -------------------- | ---------------------------- | ------------------------------ | --------------------------------------------- |
| **Port**             | `{domain}.port.ts`           | `{Domain}Port`                 | `processor.port.ts` ‚Üí `ProcessorPort`         |
| **Adapter**          | `{name}.adapter.ts`          | `{Name}` (no "Adapter" suffix) | `data-processor.adapter.ts` ‚Üí `DataProcessor` |
| **Utility**          | `{name}.ts`                  | `{Name}`                       | `data-validator.ts` ‚Üí `DataValidator`         |
| **Test**             | `{name}.test.ts`             | N/A                            | `data-processor.test.ts`                      |
| **Integration Test** | `{name}.integration.test.ts` | N/A                            | `data-processor.integration.test.ts`          |

---

## 3. Import/Export Conventions

### 3.1 Import Order & Style

```typescript
// 1. External dependencies
import { generateText } from "ai";
import { z } from "zod/v4";

// 2. Internal ports (interfaces)
import type { ProcessorPort } from "../../ports/processor.port.js";
import type { ValidatorPort } from "../../ports/validator.port.js";

// 3. Internal adapters (relative imports)
import { DataProcessor } from "../adapters/data-processor.adapter.js";
```

**Requirements:**

- Always use **`.js` extension** for imports (for ES module compatibility)
- Use **`type`** imports for type-only imports
- Use relative paths for internal modules

### 3.2 Main Index Structure

The main `src/index.ts` must follow this structure:

```typescript
// =============================================================================
// DOMAIN FEATURES
// =============================================================================

export { BusinessLogic } from "./adapters/domain-a/business-logic.adapter.js";
export { DataProcessor } from "./adapters/domain-b/data-processor.adapter.js";

// =============================================================================
// PORTS (Interfaces)
// =============================================================================

export * from "./ports/processor.port.js";
export * from "./ports/validator.port.js";
```

**Section Requirements:**

- Include both classes and their option types where applicable
- Use `export *` for ports to expose all interfaces

---

## 4. Code Patterns

### 4.1 Port Definitions

```typescript
// ports/example.port.ts
export interface ExamplePort {
  /**
   * Clear JSDoc description
   */
  readonly name: string;

  /**
   * Main method with clear signature
   */
  execute(input: string): Promise<string>;
}
```

### 4.2 Adapter Implementations

```typescript
// adapters/domain-a/example.adapter.ts
import type { ExamplePort } from "../../ports/example.port.js";

export interface ExampleOptions {
  // Configuration options
}

/**
 * Implementation of ExamplePort with specific behavior
 */
export class Example implements ExamplePort {
  constructor(
    public readonly name: string,
    private readonly options: ExampleOptions
  ) {}

  async execute(input: string): Promise<string> {
    // Implementation
  }
}
```

### 4.3 Dependency Injection Pattern

- Use constructor injection for dependencies
- Make dependencies `private readonly`
- Accept configuration through options interfaces
- Always implement the corresponding port interface

---

## 5. TypeScript Standards

### 5.1 Type Definitions

- Use **interfaces** for object shapes and contracts
- Use **type aliases** for unions, primitives, and computed types
- Always export option interfaces alongside classes
- Use generic types for reusable components

### 5.2 Class Design

- Implement port interfaces
- Use readonly properties for configuration
- Private methods for internal logic
- Clear, descriptive method and property names

---

## 6. Documentation Requirements

### 6.1 JSDoc Standards

- All public classes and interfaces must have JSDoc
- Include `@template` for generic types
- Document parameters and return types
- Include usage examples for complex APIs

### 6.2 README Structure

- Keep focused on usage and API documentation
- Include clear examples for each major component
- Document configuration options and requirements

---

## 7. Maintenance Guidelines

### 7.1 Adding New Features

1. **Define the port** (interface) first
2. **Implement the adapter** with clear naming
3. **Add comprehensive tests** (unit + integration)
4. **Update main index** with proper section placement
5. **Document public APIs** with JSDoc

### 7.2 File Operations

- **NEVER** create documentation files unless explicitly requested
- **PREFER** editing existing files over creating new ones
- **MAINTAIN** existing patterns and conventions
- **ENSURE** all imports use `.js` extensions

### 7.3 Quality Gates

- All code must pass TypeScript strict checks
- Tests must pass before committing
- Lint rules must be satisfied
- Follow established naming conventions

---

## 8. Best Practices

- ‚úÖ **DO** follow the exact naming conventions for ports vs adapters
- ‚úÖ **DO** use `.js` extensions in all imports
- ‚úÖ **DO** maintain the structured index.ts format
- ‚úÖ **DO** implement port interfaces in adapter classes
- ‚úÖ **DO** use constructor dependency injection

- ‚ùå **DON'T** include "Adapter" in class names (only in filenames)
- ‚ùå **DON'T** create new files without following the established patterns
- ‚ùå **DON'T** skip JSDoc documentation for public APIs
- ‚ùå **DON'T** break the clean architecture boundaries
- ‚ùå **DON'T** create documentation files unless explicitly requested
